import javafx.scene.control.TextArea;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * Created by Joe on 1/24/2018.
 */
public class Interpreter {

    // Status messages that can be generated by the interpreter.
    private final String OKAY_STATUS = "OK";
    private final String PROMPT_INPUT = "IN";
    private final String INDEX_OUT_OF_BOUNDS = "You indexed out of bounds.";
    private final String VALUE_CAP_EXCEEDED = "You have exceeded the value cap for a cell. You can change this in the" +
            "settings";

    private Terminal terminal; // The terminal the interpreter is writing to
    private int valueCap; // The max value that the cells can be set at (To avoid endless loops)

    private int pointer; // The current index of the pointer in the interpreter
    private char currCommand; // The current character of the code that is being executed
    private int charReader; // The current character's position in the code
    List<Integer> loops; // The loops that the interpreter may or may not be in
    List<Character> array = new ArrayList<>(Collections.singletonList((char)0)); // The list of cells
    String code; // The code being executed.

    public Interpreter(Terminal terminal, int valueCap, String code){
        this.terminal = terminal;
        this.valueCap = valueCap;

        pointer = 0;
        charReader = 0;
        loops = new ArrayList<>();

        // We run the code through the parser to strip all non legal characters first
        this.code = parser(code);
    }

    /**
     * This method gets the next character at the charReaders location and executes its action. It continues doing this
     * until EOF or error.
     * @return The result of the execution
     */
    public ExecutionResult run(){
        while(charReader < code.length()){
            currCommand = code.charAt(charReader);
            ExecutionResult result = executeCommand(currCommand);
            if(result.codeBroken() || result.getMessage().equals(PROMPT_INPUT)) {
                return result;
            }
            charReader++;
        }
        return new ExecutionResult(pointer, charReader, false, OKAY_STATUS);
    }

    /**
     * This method is called once the user has enter the character they want to input into the program. We simply
     * get the entered character and place it into the current cell and then continue running the program.
     */
    public void getInput(){
        char c = terminal.getText().charAt(terminal.getText().length() - 1);
        array.set(pointer, c);
        charReader++;
        terminal.appendText("\n");
        terminal.setCurrMode(Terminal.Mode.STATIC);
        run();
    }

    /**
     * This method runs a switch through the possible commands and based on the one input, does the appropriate action.
     * @param command The command to run
     * @return The result of the action being ran.
     */
    private ExecutionResult executeCommand(char command){
        boolean codeBroken = false;
        String message = "";

        switch(command){
            case '<':
                pointer -= 1;
                if(pointer < 0){
                    codeBroken = true;
                    message = INDEX_OUT_OF_BOUNDS;
                }
                break;
            case '>':
                pointer += 1;
                if(array.size() - 1 < pointer){
                    array.add((char)0);
                }
                break;
            case '+':
                array.set(pointer, (char)(array.get(pointer) + 1));
                if(array.get(pointer) > valueCap){
                    codeBroken = true;
                    message = VALUE_CAP_EXCEEDED;
                }
                break;
            case '-':
                array.set(pointer, (char)(array.get(pointer) - 1));
                if(array.get(pointer) < -valueCap){
                    codeBroken = true;
                    message = VALUE_CAP_EXCEEDED;
                }
                break;
            case '.':
                terminal.appendText(array.get(pointer).toString());
                break;
            case ',':
                message = PROMPT_INPUT;
                terminal.setCurrMode(Terminal.Mode.EDIT);
                break;
            case '[':
                // Note that in brainF the loops are only ran if the cells val is non 0, otherwise it skips the loop
                if(array.get(pointer) != 0){
                    loops.add(charReader);
                }
                else{
                    while(code.charAt(charReader) != ']'){
                        charReader++;
                    }
                }
                break;
            case ']':
                // Again loops only continue if the cell val is non 0, otherwise they simply exit
                if(array.get(pointer) != 0){
                    charReader = loops.get(loops.size() - 1);
                }
                else{
                    loops.remove(loops.get(loops.size()-1));
                }
                break;
        }

        return new ExecutionResult(pointer, charReader, codeBroken, message);
    }

    /**
     * This method parses the code and removes all characters that aren't recognized.
     *
     * @param code The un-modified code
     * @return The parsed resulting code
     */
    private String parser(String code){
        ArrayList<Character> chars = new ArrayList<Character>(Arrays.asList('<', '>', '+', '-', '.', ',', '[', ']'));
        String result = "";
        for(char c : code.toCharArray()){
            if(chars.contains(c)){
                result += c;
            }
        }

        return result;
    }
}
